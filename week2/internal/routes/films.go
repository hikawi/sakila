// Package routes includes a set of all API routes under /v1
package routes

import (
	"context"
	"math"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/gin-gonic/gin/binding"
	"gorm.io/gorm"
	"luny.dev/sakila/w2/internal/models"
	"luny.dev/sakila/w2/utils"
)

type FilmsHandler struct {
	DB *gorm.DB
}

type GetFilmsQuery struct {
	Page    int `form:"page,default=1" binding:"omitempty,min=1"`
	PerPage int `form:"per_page,default=20" binding:"omitempty,min=1,max=100"`
}

// PostFilmBody represents the required data for creating a new film.
// Generated by Gemini
type PostFilmBody struct {
	// REQUIRED FIELDS
	Title string `json:"title" binding:"required,max=255"`

	// language_id is NOT NULL in DB, so it's required here
	LanguageID uint8 `json:"language_id" binding:"required,gte=1"`

	// rental_duration is NOT NULL and has a default, but still required for clarity
	RentalDuration *uint8 `json:"rental_duration" binding:"omitempty,gte=1" gorm:"default:3"`

	// rental_rate is NOT NULL and has a default
	RentalRate *float32 `json:"rental_rate" binding:"omitempty,gt=0"`

	// replacement_cost is NOT NULL and has a default
	ReplacementCost *float32 `json:"replacement_cost" binding:"omitempty,gt=0"`

	// OPTIONAL FIELDS
	Description *string `json:"description" validate:"omitempty"`
	ReleaseYear *int16  `json:"release_year" validate:"omitempty,min=1901,max=2155"` // YEAR(4) range

	// Original language is nullable
	OriginalLanguageID *uint8 `json:"original_language_id" validate:"omitempty,gte=1"`

	Length *uint16 `json:"length" validate:"omitempty,gte=1"`

	// rating must be one of the enum values
	Rating *string `json:"rating" validate:"omitempty,oneof=G PG PG-13 R NC-17" gorm:"default:G"`

	// special_features uses your custom StringSet type
	SpecialFeatures *utils.StringSet `json:"special_features" validate:"omitempty"`

	// Note: FilmID and LastUpdate are omitted as they are auto-generated by the DB/GORM.
}

func (body *PostFilmBody) Mold() models.Film {
	film := models.Film{}

	film.Title = body.Title
	film.LanguageID = body.LanguageID
	film.RentalDuration = 3
	film.RentalRate = 4.99
	film.ReplacementCost = 19.99

	if body.RentalDuration != nil {
		film.RentalDuration = *body.RentalDuration
	}

	if body.RentalRate != nil {
		film.RentalRate = *body.RentalRate
	}

	if body.ReplacementCost != nil {
		film.ReplacementCost = *body.ReplacementCost
	}

	if body.Description != nil {
		film.Description = *body.Description
	}

	if body.ReleaseYear != nil {
		film.ReleaseYear = body.ReleaseYear
	}

	if body.OriginalLanguageID != nil {
		film.OriginalLanguageID = body.OriginalLanguageID
	}

	if body.Length != nil {
		film.Length = body.Length
	}

	if body.Rating != nil {
		film.Rating = *body.Rating
	}

	if body.SpecialFeatures != nil {
		film.SpecialFeatures = *body.SpecialFeatures
	}

	return film
}

func (body *PatchFilmBody) Mold() models.Film {
	film := models.Film{}

	if body.Title != nil {
		film.Title = *body.Title
	}

	if body.LanguageID != nil {
		film.LanguageID = *body.LanguageID
	}

	film.RentalDuration = 3
	film.RentalRate = 4.99
	film.ReplacementCost = 19.99

	if body.RentalDuration != nil {
		film.RentalDuration = *body.RentalDuration
	}

	if body.RentalRate != nil {
		film.RentalRate = *body.RentalRate
	}

	if body.ReplacementCost != nil {
		film.ReplacementCost = *body.ReplacementCost
	}

	if body.Description != nil {
		film.Description = *body.Description
	}

	if body.ReleaseYear != nil {
		film.ReleaseYear = body.ReleaseYear
	}

	if body.OriginalLanguageID != nil {
		film.OriginalLanguageID = body.OriginalLanguageID
	}

	if body.Length != nil {
		film.Length = body.Length
	}

	if body.Rating != nil {
		film.Rating = *body.Rating
	}

	if body.SpecialFeatures != nil {
		film.SpecialFeatures = *body.SpecialFeatures
	}

	return film
}

// PatchFilmBody represents optional data for updating an existing film.
// Generated by Gemini
type PatchFilmBody struct {
	// ALL FIELDS ARE POINTERS (Optionals)
	Title *string `json:"title" validate:"omitempty,max=255"`

	// These are foreign keys, can be updated
	LanguageID         *uint8 `json:"language_id" validate:"omitempty,gte=1"`
	OriginalLanguageID *uint8 `json:"original_language_id" validate:"omitempty,gte=1"`

	Description *string `json:"description" validate:"omitempty"`
	ReleaseYear *int16  `json:"release_year" validate:"omitempty,min=1901,max=2155"`

	RentalDuration  *uint8   `json:"rental_duration" validate:"omitempty,gte=1"`
	RentalRate      *float32 `json:"rental_rate" validate:"omitempty,gt=0"`
	Length          *uint16  `json:"length" validate:"omitempty,gte=1"`
	ReplacementCost *float32 `json:"replacement_cost" validate:"omitempty,gt=0"`

	// rating validation remains the same
	Rating *string `json:"rating" validate:"omitempty,oneof=G PG PG-13 R NC-17"`

	// special_features uses your custom StringSet type (made optional via the pointer)
	SpecialFeatures *utils.StringSet `json:"special_features" validate:"omitempty"`
}

// GetFilms retrieves a page of all films in the database.
//
// @Summary Get a list of films with pagination
// @Description Retrieves a paginated list of films from the database.
// @Tags films
// @Accept json
// @Produce json
// @Param page query int false "Page number (e.g., 1)" default(1)
// @Param per_page query int false "Items per page (e.g., 10)" default(10)
// @Success 200 {object} map[string]interface{} "Successfully retrieved films"
// @Failure 400 {object} map[string]string "Invalid query parameters"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /films [get]
func (h *FilmsHandler) GetFilms(c *gin.Context) {
	_, err := h.DB.DB()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "can't connect to database"})
		return
	}

	var query GetFilmsQuery
	if err := c.ShouldBindQuery(&query); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	ctx := context.Background()

	res, err := gorm.G[models.Film](h.DB).
		Preload("Language", nil).
		Limit(query.PerPage).
		Offset((query.Page - 1) * query.PerPage).
		Find(ctx)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	count, err := gorm.G[models.Film](h.DB).Count(ctx, "film_id")
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"data":        res,
		"page":        query.Page,
		"per_page":    query.PerPage,
		"total":       count,
		"total_pages": int64(math.Ceil(float64(count) / float64(query.PerPage))),
	})
}

// GetFilmID returns a single film by its ID.
//
// @Summary Get a film by ID
// @Description Retrieves a single film record from the database using its FilmID.
// @Tags films
// @Accept json
// @Produce json
// @Param id path int true "Film ID"
// @Success 200 {object} models.Film "Successfully retrieved the film"
// @Failure 400 {object} map[string]string "Invalid film ID format"
// @Failure 404 {object} map[string]string "Film not found"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /films/{id} [get]
func (h *FilmsHandler) GetFilmID(c *gin.Context) {
	_, err := h.DB.DB()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "can't connect to database"})
		return
	}

	idStr := c.Param("id")
	id, err := strconv.ParseInt(idStr, 10, 16)
	if err != nil || id <= 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "id must be a non-negative number"})
		return
	}

	ctx := context.Background()
	res, err := gorm.G[models.Film](h.DB).Preload("Language", nil).Where("film_id = ?", id).First(ctx)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "that film can not be found"})
		return
	}

	c.JSON(http.StatusOK, res)
}

// PostFilm creates a new film entry in the DB.
//
// @Summary Create a new film
// @Description Creates a new film record in the database.
// @Tags films
// @Accept json
// @Produce json
// @Param film body PostFilmBody true "Film data for creation"
// @Success 201 {object} models.Film "Successfully created the film"
// @Failure 400 {object} map[string]string "Invalid input data or missing required fields"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /films [post]
func (h *FilmsHandler) PostFilm(c *gin.Context) {
	_, err := h.DB.DB()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "can't connect to database"})
		return
	}

	var body PostFilmBody
	if err := c.ShouldBindWith(&body, binding.JSON); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	film := body.Mold()
	ctx := context.Background()
	err = gorm.G[models.Film](h.DB).Create(ctx, &film)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, film)
}

// PatchFilm updates a film existing record with new information
//
// @Summary Update an existing film
// @Description Updates specific fields of an existing film record identified by ID.
// @Tags films
// @Accept json
// @Produce json
// @Param id path int true "Film ID"
// @Param film body PatchFilmBody true "Film data for partial update (patch)"
// @Success 200 {object} models.Film "Successfully updated the film"
// @Failure 400 {object} map[string]string "Invalid input data or ID format"
// @Failure 404 {object} map[string]string "Film not found"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /films/{id} [patch]
func (h *FilmsHandler) PatchFilm(c *gin.Context) {
	_, err := h.DB.DB()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "can't connect to database"})
		return
	}

	idStr := c.Param("id")
	id, err := strconv.ParseInt(idStr, 10, 16)
	if err != nil || id <= 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "id must be a non-negative number"})
		return
	}

	var body PatchFilmBody
	if err := c.ShouldBindWith(&body, binding.JSON); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	film := body.Mold()
	ctx := context.Background()
	rows, err := gorm.G[models.Film](h.DB).Where("film_id = ?", id).Updates(ctx, film)
	if err != nil || rows == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
		return
	}

	updatedFilm, err := gorm.G[models.Film](h.DB).Preload("Language", nil).Where("film_id = ?", id).First(ctx)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "that film can not be found"})
		return
	}

	c.JSON(http.StatusOK, updatedFilm)
}

// DeleteFilm deletes a single record of a film
//
// @Summary Delete a film by ID
// @Description Deletes a single film record from the database using its FilmID.
// @Tags films
// @Accept json
// @Produce json
// @Param id path int true "Film ID"
// @Success 204 "Successfully deleted the film (No Content)"
// @Failure 400 {object} map[string]string "Invalid film ID format"
// @Failure 404 {object} map[string]string "Film not found"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /films/{id} [delete]
func (h *FilmsHandler) DeleteFilm(c *gin.Context) {
	_, err := h.DB.DB()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "can't connect to database"})
		return
	}

	idStr := c.Param("id")
	id, err := strconv.ParseInt(idStr, 10, 16)
	if err != nil || id <= 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "id must be a non-negative number"})
		return
	}

	ctx := context.Background()
	affected, err := gorm.G[models.Film](h.DB).Where("film_id = ?", id).Delete(ctx)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusNoContent, gin.H{"affected": affected})
}
