package routes

import (
	"context"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"fmt"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
	"luny.dev/sakila/w4/internal/models"
)

type AuthRouter struct {
	DB *gorm.DB
}

// GenerateRandomString generates a random base64 encoded string
// Generated by Gemini for a cryptographically strong random string.
func GenerateRandomString(length int) (string, error) {
	numBytes := (length*3)/4 + 1

	b := make([]byte, numBytes)
	_, err := rand.Read(b)
	if err != nil {
		return "", fmt.Errorf("failed to read random bytes: %w", err)
	}

	encodedString := base64.URLEncoding.EncodeToString(b)
	if len(encodedString) > length {
		return encodedString[:length], nil
	}
	return encodedString, nil
}

func (r AuthRouter) Register(g *gin.Context) {
	_, err := r.DB.DB()
	if err != nil {
		g.AbortWithStatusJSON(500, gin.H{"message": "unable to connect to db"})
		return
	}

	// Bind the request
	var request struct {
		Name string `json:"name"`
	}
	if err := g.ShouldBindBodyWithJSON(&request); err != nil {
		g.AbortWithStatusJSON(400, gin.H{"message": "bad request", "error": err.Error()})
		return
	}

	// Create the key
	apiKey, err := GenerateRandomString(64)
	if err != nil {
		g.AbortWithStatusJSON(500, gin.H{"message": "unable to generate a random string"})
		return
	}

	// Hash the key for saving.
	hasher := sha256.New()
	hasher.Write([]byte(apiKey))
	hashedKey := hex.EncodeToString(hasher.Sum(nil))

	ctx := context.Background()
	user := models.User{
		Name:  request.Name,
		Token: hashedKey,
	}

	err = gorm.G[models.User](r.DB).Create(ctx, &user)
	if err != nil {
		g.AbortWithStatusJSON(500, gin.H{"message": "unable to insert user"})
		return
	}

	g.JSON(201, gin.H{"api_token": apiKey})
}
